# short-url

## 機能要件と非機能要件
機能要件とは、、システムがエンドユーザに提供する機能や特徴のことである。URL短縮サービスに期待されることはシンプルである：

このシステムは、長いURLとして入力を受け取り、短縮URLを返す。

短いURLは、どのユーザがアクセスしても長いURLにリダイレクトされなければならない。

最もクリティカルな要件とともに、顧客の視点に立った付加価値の高い要件や、ビジネス価値を引き出すのに役立つ要件を検討することができる。以下のようなものがある：

* カスタムURL作成サポート

* 最も人気のあるURLなど、URLのアクセスパターンを分析する。

* URLの有効期限を設定し、一定期間が経過すると自動的に有効期限が切れてアクセスできなくなるようにする。

* プラグインベースのアーキテクチャで拡張性を確保する

* APIをサードパーティクライアントに公開し、サードパーティクライアントが自社のアプリケーションを当社のシステムに統合できるようにする。

私たちは常に、必要となりそうなものについて可能な限り多くの要件を集めるべきだが、将来の期待について考えるあまり、現在の期待を見失うようなことがあってはならない。追加要件は、拡張可能な方法でシステムを設計するのに役立ち、システムを再設計することなく新しい機能を追加することができる。

もう1つのタイプの要件は非機能要件である。NFRは、 、システムが演算する制約を決定するもので、機能的にはユーザに直接影響しないが、システム運用の品質を保証するために重要である。以下にいくつかの例を示す：

セキュリティ
システムが悪意者に悪用されないようにする。

高い可用性
年間で高い稼働率を確保する。

可観測性
システムの正常性を常時監視するために、適切なメトリックとアラートを確保する。

遅延が少ない
短いURLの作成とリダイレクト

データストア
耐久性があり、URLに対して設定された有効期限までデータの正しさを保証すること。データは、有効期限が切れるまで、またはユーザによって明示的に削除されるまで、システムに存在すること。

フォールト・トレランス
再試行処理などのメカニズムを通じて

システムアーキテクチャにおける相互運用性
システムは高いスケールでオペレーティングされ、複数のサブシステムに分割することができる。

システム規模
スケールとは、、システムに想定されるユーザ数やトラフィックのことを指す。次のような質問に答えられるようにしなければならない：

* 短いURLを生成するために、1秒あたりのユーザリクエスト数（RPS）または1秒あたりのクエリ数（QPS）はどのくらいになりそうか？

* 短いURLを長いURLにリダイレクトするために、どれだけのユーザがリクエストしたのか（あるいはシステムにどれだけの負荷がかかったのか）。システムの平均負荷とピーク負荷の両方を明確にすべきである。

* データをストアするために必要なストレージの量について、何か見当はついているのだろうか？

100％正確なデータを持っているわけではないからだ。このようなシナリオでは、少なすぎず多すぎずのバランスで、公正な仮定を立てるのがよい。以下、必要条件を仮定して話を進めよう：

* 長いURLから短いURLを生成する1,000 RPS

* 短いURLから長いURLへのリダイレクト：20,000RPS

* システムにおけるURLの平均持続期間：1年

市場には多くのデータベース・ソリューションがある。どれが我々のユースケースに最適かを決定するためには、もう一つ重要なパラメータを考慮する必要がある。これを知ることで、次のような質問に答えることができる：

* アマゾン・ダイナモDBやアマゾン・オーロラを使用した場合、私たちが負担することになるコストはどのくらいになるのだろうか？

* 最初からデータのパーティション分割が必要なのだろうか？

その他、Amazon EC2インスタンスにデプロイされるアプリケーションのインスタンスタイプやインスタンス数、AWS Lambdaのメモリ要件などを把握することも、スケールするために重要な検討事項だ。本番システムに導入し、実際のコンシューマ・トラフィックを提供する前に、実際の数値を把握するのは容易ではない。公正な仮定を立て、学習に基づいてさらに改善する。

負荷テストは、トラフィックが増加してもシステムが期待通りに動作する（システムが信頼できる）という確信を得るのに役立つ。次に、 、必要なストレージスペースについて説明しよう。

## 収納スペース
実際に必要なストレージは、使用するデータストレージソリューションのタイプに よって異なる。なぜなら、データの保存とアクセスのパターンはデータベースごとに 異なるからである。ストレージ容量の概算は、URLの数、短いURLと長いURLのスペース、ユーザのメタデータ、有効期限や作成時間などのURLのメタデータに依存する。1年間に生成されるURLの数は、1,000RPSの想定トラフィックから導き出すことができる：

1年間の合計URL数 = (1,000リクエスト/秒) × 60 (1分) × 60 (1時間) × 24 (1日) × 365 (1年) ~ 315.3億件

ストレージの計算を進める前に、短いURLの理想的な長さを割り出す必要がある。その長さは、システムが一意の短いURLを使い果たさないような長さであるべきであり、年間315億の一意のURLという必要な規模をサポートできるものでなければならない。第9章では、IPv4アドレスに代わるものとしてIPv6アドレスを取り上げた。このような問題がURL短縮システムで発生することは絶対に避けたいので、URLの長さは最初から適切な考慮のもとに計算されるべきである。安全のために12や15の長さを提案するかもしれないが、それではURLを短縮する意味がなくなってしまう。

0～9の数字とa～z、A～Zの文字から短いURLを生成することを考えることができる。これら62のユニークな文字を使って、与えられた長さのユニークなURLを生成する最大数はいくつだろうか？

長さ(1) =621= 62

長さ(6) =626= 568億

長さ(7) =627= 3.5兆ドル

長さ(8) =628= 218.3兆ドル

これらの計算から、URLシステムは6以上のURL長で必要な規模をサポートできることがわかる。将来の規模を考慮すると、URLの長さは最終的に7とすることができる。

さて、最初の質問に戻ろう。必要なストレージスペースはどのくらいか？短いURL、長いURL、有効期限、メタデータを格納する単純なデータベーススキーマを考えると、必要なストレージ容量は以下のように計算できる：

短いURL（7文字）＝7バイト

平均的な長いURL（100文字）＝100バイト

有効期限（long）＝8バイト

平均メタデータ（ユーザIP、ユーザ設定など）＝1KB

合計～1150バイト

簡単のため、1つのURLに必要なストレージを1KBとする：

1年間の合計ストレージ＝315.3億×1KB＝29.37TB

システムには、クエリのパフォーマンスを向上させるキャッシュ、分析データ、ユーザ認証データベース（システムがカスタムURLの作成、ビュー分析など、ログインユーザに追加機能を提供する場合に必要となる）などの追加ストレージ要件がある。

これらの要件を念頭に置いて、 URL短縮サービスの設計を進めよう。

デザインから始める
私たちは 要件収集のセクションで、私たちのシステムが将来どのようになるのか、市場とともに進化するためにどのような新機能を導入する可能性があるのかわからないため、あまり先のことを考えすぎてはいけないと述べた。実際に必要になったときに簡単に新機能を導入できるように、システムはオープンエンドにしておくべきである。図14-1は、定義された機能要件を満たすための、URL短縮サービスの最も基本的なアーキテクチャとユーザ対話を示している。ユーザはURL短縮サービスを使って長いURLに対応する短いURLを作成し、同じ短いURLをウェブブラウザ（または端末）で使ってURLにアクセスする。URL短縮サービスは、短いURLに対応する長いURLを見つけ出し、リクエストをリダイレクトする。

設計のために最初に考えなければならないのは、長いURLから短いURLをどのように生成し、それを最適に保存して、より高速なユーザ・ルックアップ・クエリをサポートできるかということだ。

## URL短縮アルゴリズム
長いURL は、さまざまなアルゴリズムによって短いURLに短縮することができる。そのうちのいくつかが、我々のシステムのユースケースにどのように適合するかを、ハッシュから始めて説明する。

## ハッシュ

ハッシュ関数は長いURLを入力とし、この長いURLのハッシュを出力として返す。生成されたハッシュの長さは7より大きくなる可能性があるため、システムは生成されたハッシュを短くトリミングする必要がある。このソリューションは実装が簡単だが、1つ問題がある。2つの異なる長いURLが同じハッシュを生成する可能性があり、ハッシュが異なっていても、切り捨てられた長さは同じになる可能性がある。大規模になると、この問題は頻繁に発生し、短いURLの生成がボトルネックになる可能性がある。

衝突を処理するさまざまなメソッドがある。1つの可能な解決策は、最初の7文字で切り捨て る代わりに、他の文字セットを取ることである。ハッシュ生成アプローチでは、図14-2に示すように、データストアのルックアップ（衝突の場合は複数回のルックアップ）も必要となり、演算に余分な遅延が加わる。

要するに、ハッシュ・ソリューションは我々のシステム要件にはあまり完璧ではないのだ。衝突を回避し、おそらくデータベースのルックアップも回避して、操作を高速化するオプションについて考えてみよう。

## ユニークIDの生成

ここで考慮すべき重要な点は、長いURLと短いURLは関連している必要はないということだ。これは本質的にユニークなID生成システムであり、生成されたIDを長いURLにマッピングすることができる。

ユニークなIDを生成するためのいくつかのアプローチについて説明しよう。IDは、ユーザから新しいリクエストを受け取るたびにインクリメントされるカウンタのような単純なものでもよいし、データベースのような機能でもよい。 AUTO_INCREMENTのような機能である。システム自身が（データベースを介さずに）ID生成を処理すれば、衝突処理とデータベース検索回避の両方の問題を確実に解決できる。サーバーがカウンタ値を "1 "で初期化し、新しいリクエストが来るたびにインクリメントしていると考えればよい。図14-3に示すように、マッピングをデータベースに保存し、短いURLをユーザに返すことができる。

エンコーディングに使用される0から9、aからz、AからZの英数字のシーケンスは、 、base62エンコーディングと呼ばれる。カウンタ値（10進数）にbase62エンコーディングを使用する場合、ショートURLは一意になるが、長さが7になるとは限らないことに注意：

Base62 (1) = 1

Base62 (10) = A

Base62 (61) = z

Base62 (62) = 10

Base62 (63) = 11

Base62 (1000001) = 4C93

長さが常に7であることを保証するために、生成されたbase62の値に、英数字セットとは互いに排他的な他の文字セット（例えば、_、#など）からランダムな文字を追加することができる。

カウンタ値のメンテナンスについては決めていない。単純な解決策は、アプリケーションのグローバル・カウンタ変数を維持し、新しい短いURL生成のたびに更新することである。しかし、アプリケーションが動作しているマシンが複数存在する可能性があり、カウンタ値が重複する可能性がある。たとえマシンが1台であっても、そのマシンがダウンするリスクがあり、カウンタ値が再びゼロから始まることになる。

これを解決するために、このグローバルカウンタをデータベースで管理することが考えられる。こうすることで、1台のマシンがダウンした場合（カウンタが毎回ゼロに初期化されない）や、複数のマシンがURL生成を担当する場合（マシン間でカウンタ値が重複する）の問題を解決できる。しかし、レースコンディションを避けるために複数のアプリケーションスレッドが同時にカウンタにアクセスすることを許可することはできないし、ロックをかける（1台のマシンが値を読み取り更新する）と演算子の遅延が大きくなるため、問題を引き起こす可能性もある。

アプリケーションのパフォーマンスを最適化するために、アーキテクチャ全体をさらに単純化しよう。短いURLは長いURLに依存しないので、短いURLを事前に生成するシステムにさらなる責任を代入することができる。こうすることで、複数のマシンが事前に生成されたID（短いURL）を利用することができ、すべてのボトルネックを解決することができる。

私たちのURL短縮サービスは、短いURLの事前生成と、より高速なアクセスのためのメモリへの保持を担当する追加コンポーネントで構成されている。ここで行うべき重要なレスポンスは、この追加責任をURL短縮サービスに与えるか、独立したサービスとしてホストするかである。(第8章ではモノリシックアーキテクチャとマイクロサービスアーキテクチャ、および各サービスではどのような利点があるのかを説明した)。

単一のコンポーネントであれば、（少なくとも最初のうちは）比較的少ないハードウェアコストで済み、サービス間のネットワーク呼び出しが不要なため遅延も少なくなる。ここで決断を下すために考慮する必要があるのは、メインのアプリケーションの一部としてホストするのではなく、独立したコンポーネントとした場合、どのような価値が得られるかということだ。別のID生成サービスや鍵生成サービス（KGS）は、他のユースケースにとって有益であり、これは独立した責任であり、URL短縮サービスに関連付けられている必要はない。このことから、図14-4に示すように、一意のキーを生成し、リクエスト/レスポンス時にURL短縮サービスにそれを渡す責任を持つ別のサービスをホストするというアイデアを採用することにする。

追加の分析パイプラインがアーキテクチャに含まれている。URL短縮サービスは、ユーザの活動のイベントをキューに公開し、分析パイプラインは、データを分析し、インサイトを提供する。

さて、KGSをもう少し詳しく見てみよう。

鍵生成サービス
KGSは、URL短縮サービスからのリクエストに応じてユニークなIDを提供するという単純な責任を負っている。KGSのトラフィックを確実に制御し、URL短縮システムをより効率的にするために、演算子はIDのリストを提供することができる-例えば、1回の演算子で1000個。KGSがどのように機能するのか、もう少し掘り下げてみよう。

MySQLのAUTO_INCREMENT 、PostgreSQLの、データベースの自動インクリメント機能を使うことを検討する。 SERIALまたは SEQUENCE.この機能はリーダー・インスタンス（複数のデータベース・インスタンスがある場合）に適用され、IDの保守のための単一の障害点となり、システム全体の可用性を妨げる可能性がある。さらに、水平スケーラブルなNoSQLデータベースのようなマルチインスタンス・データベースの場合、この機能の実装は非常に難しくなる。Flickrのアーキテクチャからヒントを得ることができる。このアーキテクチャでは、MySQLのオートインクリメント機能とREPLACE INTO クエリを使用して、新しいクエリごとにグローバルに一意な新しいIDを取得している：

```sql
CREATE TABLE `Tickets64` (
  `id` bigint(20) unsigned NOT NULL auto_increment,
  `stub` char(1) NOT NULL default ‘‘,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `stub` (`stub`)
) ENGINE=InnoDB
 
 
REPLACE INTO Tickets64 (stub) VALUES (‘a’);
SELECT LAST_INSERT_ID();
```

システムの可用性を高め、単一障害点を避けるため、2つのデータベース・サーバーを使用し、偶数と奇数で開始し、衝突を避けるためにオフセットを2とする：

```
TicketServer1:
auto-increment-increment = 2
auto-increment-offset = 1
 
TicketServer2:
auto-increment-increment = 2
auto-increment-offset = 2
```

さらに、これら2つのデータベースは、致命的なシナリオが発生した場合に備えてバックアップが常に保持されるように、定期的にスナップショットを取る必要がある。テーブル内には1行しか保持されないので、サーバがストレージ容量を使い果たすことはない。

図14-5はID生成のためのKGSとチケットサーバとのやりとりを示している。

2つのチケットサーバはそれぞれ偶数と奇数のIDを生成するが、チケットサーバが1つだけでなく複数の地域にデプロイされる場合、この管理オーバーヘッドは増加する。地域間の一意性を確保するための一つの解決策として、短いURLにデータセンターの接頭辞を追加することが考えられる。例えば、us-east-1は1、eu-west-1は2といった具合である。

KGSは、APIやクライアント・オンボーディング・コンフィギュレーションでのクライアントの入力に基づき、複数のタイプの鍵生成をサポートするように拡張することができる。これにより、KGSはあらゆる種類の識別子を生成するための単一のシステムとなる。 URL短縮サービスでサポートする必要があるAPIについて説明しよう。


## システムAPI
API クライアントは、サポートされている関数を利用するために、システムとの統合を支援する。URL短縮サービスは2つの主要なAPIをサポートすべきである。以下のコードスニペットは、短いURLを作成するためのAPIシグネチャを示している：

```
POST /v1/createShortUrl
{
    longUrl,
    customUrl,
    expiry,
    userMetadata
}
```

longUrl パラメータは、短いURLを生成するためのAPIリクエストで必須である。追加属性は、アプリケーションの他の関数をサポートするために追加される：

customUrl
ユーザがランダムな7文字の文字列の代わりにカスタムURLを生成したい場合に役立つ。このパラメータを処理するために、URL短縮サービスは、カスタムURLがすでに作成されているかどうかを直接データベースでチェックし、そうでない場合は、カスタムURLの長いURLへのマッピングがデータベースに格納される。

expiry
ユーザが、システムによって定義される代わりに、URLのカスタム期限を指定できるようにする。

userMetadata
IPアドレス、地理的位置、ブラウザなど、ユーザに関する追加情報を収集するために使用され、分析に役立つ。


APIのレスポンスは成功か失敗のどちらかである。第6章のHTTPステータスコードの議論を覚えているかもしれない。ステータスコードは、クライアントがサーバから受信したHTTPレスポンスの種類を判断するのに役立つ。クライアントが失敗シナリオのレスポンスを理解し、再試行などのアクションを取れるように、両方のレスポンスに対して適切なメカニズムを定義すべきである。失敗の原因は、クライアント側のパラメータが無効であったり、バックエンドのアプリケーションに問題があったりする。

成功したレスポンスの例を紹介しよう：

```
HTTP/1.1 200 OK
{
    “shortUrl”: “https://oreil.ly/SystemDesignOnAWS”
}
```

以下は、失敗したレスポンスの例である：

```
HTTP/1.1 500 Internal Server Error
{
    “error”: “An error occurred while processing your request”    
}
```

ユーザが短いURLを作成し、それを他の人と共有したり、自分でアクセスしたりすると、APIリクエストとレスポンスは次のようになる：

```
GET v1/getLongUrl
{
    shortUrl,
    userMetadata
}
```

これが成功したレスポンスだ：

```
HTTP/1.1 302 Found
Location: https://www.oreilly.com/library/view/system-design-on/9781098146887
```
 
そして、これが失敗したレスポンスだ：

```
HTTP/1.1 404 Not Found
{
    “error”: “short url doesn’t exist”
}
```

本番でシステム をデプロイするために使用するAWSコンポーネントに進む前に、その他の考慮事項について説明しよう。

## システムに関する考察
ここまでで、我々はアーキテクチャの中で2つのサービスを提案した。URL短縮サービスと、エンドツーエンドの機能をサポートするKGSである。URL短縮サービスは、短いURLの生成とリダイレクトを担当する。APIは1つのシステムでサポートできるほどシンプルだが、両APIのトラフィックパターンはかなり異なる。URLリダイレクトのトラフィックはURL生成のトラフィックよりもはるかに高くなるだろう。

有名人が短いURLを生成し、それをソーシャルメディアプラットフォームのフォロワーと共有することを想像してみてほしい。フォロワー全員がそのURLにアクセスしようとし、システム全体のトラフィックが増加する。このようなシナリオでは、単一のシステムで始め、トラフィックの処理が問題になった場合は進化させることをお勧めする。

システムを2つのコンポーネントに分けると、データベースが2つの別々のサービスからアクセスされるなど、余計なオーバーヘッドが発生する可能性がある。URL短縮サービスは読み取りと書き込みの両方のユースケースを持ち、URLリダイレクトサービスはデータベースの読み取りユースケースを持つ。一般化として、2つのサービスが1つのデータベースと直接やりとりするのは良いアイデアではない。最も堅牢なソリューションは、キャッシュメンテナンスとともにすべてのデータベース演算を処理する責任を持つ別のサービスを介してデータベース演算を公開することである。市場で入手可能なデータベース・ソリューションは多種多様であるため、データベースの選択も最終決定する必要がある。


## データベースの選択

特定のユースケースに最適なデータベースを選択するには、複数の要因が関係する。第2章、第3章、第10章で、さまざまなタイプのデータベースを検討し、比較した。図3-4は、データベースの選択肢をナビゲートし、特定のデータベースを最終決定する方法を説明する。データ型から始め、アプリケーションに必要なクエリパターンを探す。最初にURL短縮サービスを考えてみよう。

## URL短縮サービス
URL短縮サービスの場合、データは構造化されており、予想されるクエリパターンは以下の通りである：

特定の短いURLに対して長いURLを取得する。

特定の期間におけるユーザのすべてのURLを取得する。これはセカンダリクエリパターンで、ログインユーザにのみ必要である。

これらのクエリパターンは、リレーショナルデータベースでも非リレーショナルデータベースでも解決可能であり、これまでの専門知識に基づいて選択することができる。リレーショナルデータベースをデプロイに選択する場合は、最初から論理的なパーティショニング戦略を推奨する。この章の文脈では、AWSのキー・バリュー・データベースで話を進める：Amazon DynamoDBだ。DynamoDBには、水平スケーリング、リード/ライトレプリカのスケールアップの心配のないインフラ管理、TTL設定、分析のためのDynamoDBストリームなど、すぐに利用できる利点がたくさんある。

DynamoDBのパーティションキーとソートキーを定義する：

パーティション・キー = {短いURL}。

ソートキー = SU

ソートキーは常に定数文字列であるため、先のスキーマではソートキーの定義を省略できる。定数は、DynamoDBにパーティションキーを短いURLとして他のエントリ(長いURLマッピングとは別に)を格納するのに役立つので、推奨される。ユーザが作成したすべてのURLを取得するにはGSIが必要であり、そのために以下のスキーマを使用することができる：

パーティション・キー = {userId}

ソートキー = u#{タイムスタンプ}。

タイムスタンプはソートキーに含まれ、特定の時間フレームのURLを検索するのに役立つ。では、KGSのデータベースの選択について説明しよう。

## KGS
ID生成ロジックはチケットサーバに依存する。さらに、KGSはクエリを高速に処理するために、いくつかのIDをバッファに保持する必要がある。ロジックは、バッファに10,000個のIDを保持するような単純なもので、アプリケーションのトラフィックに応じて数を調整することができる。この目的のために、RedisやMemcachedフレーバーを持つAmazon ElastiCacheのようなインメモリ・データストアを利用することができる。RedisリストはIDを保存する一つの方法だ。

KGSは特定のインスタンスでどのIDがURL短縮サービスに返されたかの監査履歴を保持しないし、私たちもその要求を持っていない。これは必要であれば組み込むことができ、キャッシュストアは設定された永続データストアの上で促進される。

我々は、個々のコンポーネントと、要求事項を満たすためにシステムがどのように演算されるかについて議論してきた。アプリケーションのビジネス面も重要である。私たちは最終的にシステムから収益を得たいと考えている。収益を生み出す例としては、URLアナリティクスや有料ユーザ向けのカスタムURLドメインの提供などが考えられる。アナリティクスはそれ自体がURL短縮システムの大きな部分を占めている。しかし、次のセクションでは、カスタムドメインのサポートをどのように 。

## カスタム・ドメイン・サポート
システムの要件の1つは、サードパーティのクライアントにAPIを公開できる拡張性のあるシステム、つまりマルチテナント・システムを構築することである。例えば、Google DriveがBitlyのサービスを利用してURLを短縮しているが、GoogleはBitlyの短縮URLではなく、Googleのカスタム短縮URLをユーザと共有したいと考えているとする。

システムでカスタムドメイン・サポートを有効にすることは、複数のURL短縮シス テムをそれぞれ異なるドメイン名で管理することと多少似ている。ここで考慮すべき重要な点は、システムが、仮想的（または論理的）分離を行うか、物理的分離を行うかである。物理的な分離とは 、複数のシステムを並行してデプロイし、それぞれが特定のドメインにサービスを提供することを意味し、仮想的な分離とは、内部コードの分離やコンフィギュレーションによって、同じシステムがすべてのクライアントに対応することを意味する。


短いURLと長いURLのマッピングを管理する1つのDynamoDBテーブルを使ってこれを解決してみよう。DynamoDBは、プライマリキーの一部としてパーティションキーとソートキーを必要とするので、システムは定義する：

パーティション・キー = {短いURL}。

ソートキー = {テナントID}。

tenant ID は、異なるテナント（URL短縮システムに搭載されているシステム）を把握するために有用な識別情報である。short URL はオンボードシステムによるAPI呼び出しによって作成されるので、リクエストの一部としてtenant ID を渡すことが期待される。tenant ID はシステムがオンボードされたときに作成することもできるし、API 呼び出しでシステムが使用した資格情報に基づいて割り出すこともできる。getコールでも、tenant ID 、アクセスされるドメインに基づいて導き出すことができる。キャッシュストアのキーは、簡単に検索できるように、short URL とtenant ID の組み合わせで作成すべきである。

テナントごとに異なるテーブルを作成することは間違いなく可能だが、オンボードシステムの数と演算子の規模に基づいて慎重に判断する必要がある。ハイブリッド・アプローチを取ることもできる。、セルベース・アーキテクチャと呼ばれることが多い。各セルはオンボード・テナントのセットを担当し、システムはどのセルが特定のテナントを担当するかのマッピングを管理する。セル間でデータを共有しないため、セルは独立して運用できる。このアーキテクチャで考慮すべきもう1つの点は、セル間のロードバランサである。1つのセルは1つのテナントだけをオンボードするかもしれないが、別のセルには10テナントが含まれるかもしれない。
